"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_azureextensionui_1 = require("vscode-azureextensionui");
const connectToGitHub_1 = require("./connectToGitHub");
const extensionVariables_1 = require("./extensionVariables");
const localize_1 = require("./localize");
const ScmType_1 = require("./ScmType");
const nonNull_1 = require("./utils/nonNull");
function editScmType(client, node, context, newScmType) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = yield client.getSiteConfig();
        // tslint:disable-next-line:strict-boolean-expressions
        newScmType = newScmType ? newScmType : yield showScmPrompt(nonNull_1.nonNullProp(config, 'scmType'));
        if (newScmType === ScmType_1.ScmType.GitHub) {
            if (config.scmType !== ScmType_1.ScmType.None) {
                // GitHub cannot be configured if there is an existing configuration source-- a limitation of Azure
                throw new Error(localize_1.localize('configurationError', 'Configuration type must be set to "None" to connect to a GitHub repository.'));
            }
            yield connectToGitHub_1.connectToGitHub(node, client, context);
        }
        else {
            config.scmType = newScmType;
            // to update one property, a complete config file must be sent
            yield client.updateConfiguration(config);
        }
        extensionVariables_1.ext.outputChannel.appendLine(localize_1.localize('deploymentSourceUpdated,', 'Deployment source for "{0}" has been updated to "{1}".', client.fullName, newScmType));
        if (newScmType === ScmType_1.ScmType.LocalGit) {
            const user = yield client.getPublishingUser();
            if (user.publishingUserName) {
                // first time users must set up deployment credentials via the Portal or they will not have a UserName
                const gitCloneUri = `https://${user.publishingUserName}@${client.gitUrl}`;
                extensionVariables_1.ext.outputChannel.appendLine(localize_1.localize('gitCloneUri', 'Git Clone Uri for "{0}": "{1}"', client.fullName, gitCloneUri));
            }
        }
        // returns the updated scmType
        return newScmType;
    });
}
exports.editScmType = editScmType;
function showScmPrompt(currentScmType) {
    return __awaiter(this, void 0, void 0, function* () {
        const currentSource = localize_1.localize('currentSource', '(Current source)');
        const scmQuickPicks = [];
        // generate quickPicks to not include current type
        for (const key of Object.keys(ScmType_1.ScmType)) {
            const scmType = ScmType_1.ScmType[key];
            if (scmType === currentScmType) {
                // put the current source at the top of the list
                scmQuickPicks.unshift({ label: scmType, description: currentSource, data: undefined });
            }
            else {
                scmQuickPicks.push({ label: scmType, description: '', data: scmType });
            }
        }
        const options = {
            placeHolder: localize_1.localize('scmPrompt', 'Select a new source.'),
            suppressPersistence: true
        };
        const newScmType = (yield extensionVariables_1.ext.ui.showQuickPick(scmQuickPicks, options)).data;
        if (newScmType === undefined) {
            // if the user clicks the current source, treat it as a cancel
            throw new vscode_azureextensionui_1.UserCancelledError();
        }
        else {
            return newScmType;
        }
    });
}
//# sourceMappingURL=editScmType.js.map