"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ms_rest_1 = require("ms-rest");
const request = require("request");
const timers_1 = require("timers");
const vscode = require("vscode");
const vscode_azureextensionui_1 = require("vscode-azureextensionui");
const extensionVariables_1 = require("./extensionVariables");
const getKuduClient_1 = require("./getKuduClient");
const localize_1 = require("./localize");
const pingFunctionApp_1 = require("./pingFunctionApp");
const signRequest_1 = require("./signRequest");
const logStreams = new Map();
function getLogStreamId(client, logsPath) {
    return `${client.id}${logsPath}`;
}
function startStreamingLogs(client, verifyLoggingEnabled, logStreamLabel, logsPath = '') {
    return __awaiter(this, void 0, void 0, function* () {
        const kuduClient = yield getKuduClient_1.getKuduClient(client);
        const logStreamId = getLogStreamId(client, logsPath);
        const logStream = logStreams.get(logStreamId);
        if (logStream && logStream.isConnected) {
            logStream.outputChannel.show();
            // tslint:disable-next-line:no-floating-promises
            extensionVariables_1.ext.ui.showWarningMessage(localize_1.localize('logStreamAlreadyActive', 'The log-streaming service for "{0}" is already active.', logStreamLabel));
            return logStream;
        }
        else {
            yield verifyLoggingEnabled();
            const outputChannel = logStream ? logStream.outputChannel : vscode.window.createOutputChannel(localize_1.localize('logStreamLabel', '{0} - Log Stream', logStreamLabel));
            extensionVariables_1.ext.context.subscriptions.push(outputChannel);
            outputChannel.show();
            outputChannel.appendLine(localize_1.localize('connectingToLogStream', 'Connecting to log stream...'));
            const httpRequest = new ms_rest_1.WebResource();
            yield signRequest_1.signRequest(httpRequest, kuduClient.credentials);
            const requestApi = request.defaults(httpRequest);
            return yield new Promise((onLogStreamCreated) => {
                // Intentionally setting up a separate telemetry event and not awaiting the result here since log stream is a long-running action
                // tslint:disable-next-line:no-floating-promises
                vscode_azureextensionui_1.callWithTelemetryAndErrorHandling('appService.streamingLogs', function () {
                    return __awaiter(this, void 0, void 0, function* () {
                        this.suppressErrorDisplay = true;
                        let timerId;
                        if (client.isFunctionApp) {
                            // For Function Apps, we have to ping "/admin/host/status" every minute for logging to work
                            // https://github.com/Microsoft/vscode-azurefunctions/issues/227
                            yield pingFunctionApp_1.pingFunctionApp(client);
                            timerId = timers_1.setInterval(() => __awaiter(this, void 0, void 0, function* () { return yield pingFunctionApp_1.pingFunctionApp(client); }), 60 * 1000);
                        }
                        yield new Promise((onLogStreamEnded, reject) => {
                            let newLogStream;
                            const logsRequest = requestApi(`${client.kuduUrl}/api/logstream/${logsPath}`);
                            newLogStream = {
                                dispose: () => {
                                    logsRequest.removeAllListeners();
                                    logsRequest.destroy();
                                    outputChannel.show();
                                    if (timerId) {
                                        clearInterval(timerId);
                                    }
                                    outputChannel.appendLine(localize_1.localize('logStreamDisconnected', 'Disconnected from log-streaming service.'));
                                    newLogStream.isConnected = false;
                                    onLogStreamEnded();
                                },
                                isConnected: true,
                                outputChannel: outputChannel
                            };
                            logsRequest.on('data', (chunk) => {
                                outputChannel.appendLine(chunk.toString());
                            }).on('error', (err) => {
                                if (timerId) {
                                    clearInterval(timerId);
                                }
                                newLogStream.isConnected = false;
                                outputChannel.show();
                                outputChannel.appendLine(localize_1.localize('logStreamError', 'Error connecting to log-streaming service:'));
                                outputChannel.appendLine(vscode_azureextensionui_1.parseError(err).message);
                                reject(err);
                            }).on('complete', () => {
                                newLogStream.dispose();
                            });
                            logStreams.set(logStreamId, newLogStream);
                            onLogStreamCreated(newLogStream);
                        });
                    });
                });
            });
        }
    });
}
exports.startStreamingLogs = startStreamingLogs;
function stopStreamingLogs(client, logsPath = '') {
    return __awaiter(this, void 0, void 0, function* () {
        const logStreamId = getLogStreamId(client, logsPath);
        const logStream = logStreams.get(logStreamId);
        if (logStream && logStream.isConnected) {
            logStream.dispose();
        }
        else {
            yield vscode.window.showWarningMessage(localize_1.localize('alreadyDisconnected', 'The log-streaming service is already disconnected.'));
        }
    });
}
exports.stopStreamingLogs = stopStreamingLogs;
//# sourceMappingURL=startStreamingLogs.js.map