"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_1 = require("vscode");
const localize_1 = require("../localize");
const ScmType_1 = require("../ScmType");
const javaUtils_1 = require("../utils/javaUtils");
const randomUtils_1 = require("../utils/randomUtils");
const deployWar_1 = require("./deployWar");
const deployZip_1 = require("./deployZip");
const localGitDeploy_1 = require("./localGitDeploy");
function deploy(client, fsPath, configurationSectionName, telemetryProperties) {
    return __awaiter(this, void 0, void 0, function* () {
        const config = yield client.getSiteConfig();
        // We use the AppServicePlan in a few places, but we don't want to delay deployment, so start the promise now and save as a const
        const aspPromise = client.getAppServicePlan();
        if (telemetryProperties) {
            try {
                telemetryProperties.sourceHash = randomUtils_1.randomUtils.getPseudononymousStringHash(fsPath);
                telemetryProperties.destHash = randomUtils_1.randomUtils.getPseudononymousStringHash(client.fullName);
                telemetryProperties.scmType = String(config.scmType);
                telemetryProperties.isSlot = client.isSlot ? 'true' : 'false';
                telemetryProperties.alwaysOn = config.alwaysOn ? 'true' : 'false';
                telemetryProperties.linuxFxVersion = String(config.linuxFxVersion);
                telemetryProperties.nodeVersion = String(config.nodeVersion);
                telemetryProperties.pythonVersion = String(config.pythonVersion);
                telemetryProperties.hasCors = config.cors ? 'true' : 'false';
                telemetryProperties.hasIpSecurityRestrictions = config.ipSecurityRestrictions && config.ipSecurityRestrictions.length > 0 ? 'true' : 'false';
                telemetryProperties.javaVersion = String(config.javaVersion);
                client.getState().then((state) => {
                    telemetryProperties.state = state;
                }, () => {
                    // ignore
                });
                aspPromise.then((plan) => {
                    if (plan) {
                        telemetryProperties.planStatus = String(plan.status);
                        telemetryProperties.planKind = String(plan.kind);
                        if (plan.sku) {
                            telemetryProperties.planSize = String(plan.sku.size);
                        }
                    }
                }, () => {
                    // ignore
                });
            }
            catch (error) {
                // Ignore
            }
        }
        if (javaUtils_1.javaUtils.isJavaSERuntime(config.linuxFxVersion)) {
            yield javaUtils_1.javaUtils.configureJavaSEAppSettings(client);
        }
        yield vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Notification, title: localize_1.localize('deploying', 'Deploying to "{0}"... Check output window for status.', client.fullName) }, () => __awaiter(this, void 0, void 0, function* () {
            switch (config.scmType) {
                case ScmType_1.ScmType.LocalGit:
                    yield localGitDeploy_1.localGitDeploy(client, fsPath);
                    break;
                case ScmType_1.ScmType.GitHub:
                    throw new Error(localize_1.localize('gitHubConnected', '"{0}" is connected to a GitHub repository. Push to GitHub repository to deploy.', client.fullName));
                default: //'None' or any other non-supported scmType
                    if (javaUtils_1.javaUtils.isJavaTomcatRuntime(config.linuxFxVersion)) {
                        yield deployWar_1.deployWar(client, fsPath);
                        break;
                    }
                    yield deployZip_1.deployZip(client, fsPath, configurationSectionName, aspPromise);
                    break;
            }
        }));
    });
}
exports.deploy = deploy;
//# sourceMappingURL=deploy.js.map