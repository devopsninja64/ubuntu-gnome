"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const azureStorage = require("azure-storage");
const extensionVariables_1 = require("../extensionVariables");
const localize_1 = require("../localize");
const formatDeployLog_1 = require("./formatDeployLog");
/**
 * Method of deployment that is only intended to be used for Linux Consumption Function apps because it doesn't support kudu pushDeployment
 * To deploy with Run from Package on a Windows plan, create the app setting "WEBSITE_RUN_FROM_PACKAGE" and set it to "1".
 * Then deploy via "zipdeploy" as usual.
 */
function deployToStorageAccount(client, zipFilePath) {
    return __awaiter(this, void 0, void 0, function* () {
        const blobName = azureStorage.date.secondsFromNow(0).toISOString().replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, '').replace(/\s/g, '');
        const blobService = yield createBlobService(client);
        extensionVariables_1.ext.outputChannel.appendLine(formatDeployLog_1.formatDeployLog(client, localize_1.localize('creatingBlob', 'Uploading zip package to storage container...')));
        const blobUrl = yield createBlobFromZip(blobService, zipFilePath, blobName);
        const appSettings = yield client.listApplicationSettings();
        // tslint:disable-next-line:strict-boolean-expressions
        appSettings.properties = appSettings.properties || {};
        // They recently renamed 'ZIP' to 'PACKAGE'. However, they said 'ZIP' would be supported indefinitely, so we will use that until we're confident the 'PACKAGE' change has fully rolled out
        const WEBSITE_RUN_FROM_PACKAGE = 'WEBSITE_RUN_FROM_ZIP';
        appSettings.properties[WEBSITE_RUN_FROM_PACKAGE] = blobUrl;
        yield client.updateApplicationSettings(appSettings);
        extensionVariables_1.ext.outputChannel.appendLine(formatDeployLog_1.formatDeployLog(client, localize_1.localize('syncingTriggers', 'Syncing triggers...')));
        yield client.syncFunctionTriggers();
    });
}
exports.deployToStorageAccount = deployToStorageAccount;
function createBlobService(client) {
    return __awaiter(this, void 0, void 0, function* () {
        let name;
        let key;
        // Use same storage account as AzureWebJobsStorage for deployments
        const azureWebJobsStorageKey = 'AzureWebJobsStorage';
        const settings = yield client.listApplicationSettings();
        if (settings.properties && settings.properties[azureWebJobsStorageKey]) {
            const accountName = settings.properties[azureWebJobsStorageKey].match(/AccountName=([^;]*);?/);
            const accountKey = settings.properties[azureWebJobsStorageKey].match(/AccountKey=([^;]*);?/);
            if (accountName && accountKey) {
                name = accountName[1];
                key = accountKey[1];
                return azureStorage.createBlobService(name, key);
            }
        }
        throw new Error(localize_1.localize('"{0}" app setting is required for Run From Package deployment.', azureWebJobsStorageKey));
    });
}
function createBlobFromZip(blobService, zipFilePath, blobName) {
    return __awaiter(this, void 0, void 0, function* () {
        const containerName = 'azureappservice-run-from-package';
        yield new Promise((resolve, reject) => {
            blobService.createContainerIfNotExists(containerName, (err) => {
                if (err !== null) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
        yield new Promise((resolve, reject) => {
            blobService.createBlockBlobFromLocalFile(containerName, blobName, zipFilePath, (error, _result, _response) => {
                if (error !== null) {
                    reject(error);
                }
                else {
                    resolve();
                }
            });
        });
        const sasToken = blobService.generateSharedAccessSignature(containerName, blobName, {
            AccessPolicy: {
                Permissions: azureStorage.BlobUtilities.SharedAccessPermissions.READ + azureStorage.BlobUtilities.SharedAccessPermissions.LIST,
                Start: azureStorage.date.secondsFromNow(-10),
                // for clock desync
                Expiry: azureStorage.date.daysFromNow(365),
                ResourceTypes: azureStorage.BlobUtilities.BlobContainerPublicAccessType.BLOB
            }
        });
        return blobService.getUrl(containerName, blobName, sasToken, true);
    });
}
//# sourceMappingURL=deployToStorageAccount.js.map