"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const opn = require("opn");
const git = require("simple-git/promise");
const vscode = require("vscode");
const vscode_azureextensionui_1 = require("vscode-azureextensionui");
const extensionVariables_1 = require("../extensionVariables");
const getKuduClient_1 = require("../getKuduClient");
const localize_1 = require("../localize");
const nonNull_1 = require("../utils/nonNull");
const formatDeployLog_1 = require("./formatDeployLog");
const waitForDeploymentToComplete_1 = require("./waitForDeploymentToComplete");
function localGitDeploy(client, fsPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const kuduClient = yield getKuduClient_1.getKuduClient(client);
        const publishCredentials = yield client.getWebAppPublishCredential();
        const remote = nonNull_1.nonNullProp(publishCredentials, 'scmUri');
        const localGit = git(fsPath);
        try {
            const status = yield localGit.status();
            if (status.files.length > 0) {
                const message = localize_1.localize('localGitUncommit', '{0} uncommitted change(s) in local repo "{1}"', status.files.length, fsPath);
                const deployAnyway = { title: localize_1.localize('deployAnyway', 'Deploy Anyway') };
                yield extensionVariables_1.ext.ui.showWarningMessage(message, { modal: true }, deployAnyway, vscode_azureextensionui_1.DialogResponses.cancel);
            }
            yield verifyNoRunFromPackageSetting(client);
            yield localGit.push(remote, 'HEAD:master');
        }
        catch (err) {
            // tslint:disable-next-line:no-unsafe-any
            if (err.message.indexOf('spawn git ENOENT') >= 0) {
                const installString = localize_1.localize('Install', 'Install');
                const input = yield vscode.window.showErrorMessage(localize_1.localize('GitRequired', 'Git must be installed to use Local Git Deploy.'), installString);
                if (input === installString) {
                    // tslint:disable-next-line:no-unsafe-any
                    opn('https://git-scm.com/downloads');
                }
                return undefined;
                // tslint:disable-next-line:no-unsafe-any
            }
            else if (err.message.indexOf('error: failed to push') >= 0) {
                const forcePush = { title: localize_1.localize('forcePush', 'Force Push') };
                const pushReject = localize_1.localize('localGitPush', 'Push rejected due to Git history diverging.');
                yield extensionVariables_1.ext.ui.showWarningMessage(pushReject, forcePush, vscode_azureextensionui_1.DialogResponses.cancel);
                yield localGit.push(remote, 'HEAD:master', { '-f': true });
            }
            else {
                throw err;
            }
        }
        extensionVariables_1.ext.outputChannel.appendLine(formatDeployLog_1.formatDeployLog(client, (localize_1.localize('localGitDeploy', `Deploying Local Git repository to "${client.fullName}"...`))));
        yield waitForDeploymentToComplete_1.waitForDeploymentToComplete(client, kuduClient);
    });
}
exports.localGitDeploy = localGitDeploy;
function verifyNoRunFromPackageSetting(client) {
    return __awaiter(this, void 0, void 0, function* () {
        let updateSettings = false;
        const runFromPackageSettings = ['WEBSITE_RUN_FROM_PACKAGE', 'WEBSITE_RUN_FROM_ZIP'];
        const applicationSettings = yield client.listApplicationSettings();
        for (const settingName of runFromPackageSettings) {
            if (applicationSettings.properties && applicationSettings.properties[settingName]) {
                delete applicationSettings.properties[settingName];
                extensionVariables_1.ext.outputChannel.appendLine(formatDeployLog_1.formatDeployLog(client, localize_1.localize('deletingSetting', 'Deleting setting "{0}"...', settingName)));
                updateSettings = true;
            }
        }
        if (updateSettings) {
            yield client.updateApplicationSettings(applicationSettings);
        }
    });
}
//# sourceMappingURL=localGitDeploy.js.map