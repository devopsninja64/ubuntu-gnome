"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const path = require("path");
const vscode_1 = require("vscode");
const vscode_azureextensionui_1 = require("vscode-azureextensionui");
const waitForDeploymentToComplete_1 = require("../deploy/waitForDeploymentToComplete");
const extensionVariables_1 = require("../extensionVariables");
const getKuduClient_1 = require("../getKuduClient");
const localize_1 = require("../localize");
const nonNull_1 = require("../utils/nonNull");
// Kudu DeployStatus: https://github.com/projectkudu/kudu/blob/a13592e6654585d5c2ee5c6a05fa39fa812ebb84/Kudu.Contracts/Deployment/DeployStatus.cs
var DeployStatus;
(function (DeployStatus) {
    DeployStatus[DeployStatus["Building"] = 0] = "Building";
    DeployStatus[DeployStatus["Deploying"] = 1] = "Deploying";
    DeployStatus[DeployStatus["Pending"] = 2] = "Pending";
    DeployStatus[DeployStatus["Failed"] = 3] = "Failed";
    DeployStatus[DeployStatus["Success"] = 4] = "Success";
})(DeployStatus || (DeployStatus = {}));
class DeploymentTreeItem extends vscode_azureextensionui_1.AzureTreeItem {
    constructor(parent, deployResult) {
        super(parent);
        this.contextValue = DeploymentTreeItem.contextValue;
        this._deployResult = deployResult;
        this.receivedTime = nonNull_1.nonNullProp(deployResult, 'receivedTime');
        let message = nonNull_1.nonNullProp(deployResult, 'message');
        message = this.getFirstLine(message);
        if (message.length > 50) { /* truncate long messages and add "..." */
            message = `${message.substring(0, 50)}...`;
        }
        this.label = `${this.id.substring(0, 7)} - ${message}`;
    }
    get iconPath() {
        return {
            light: path.join(__filename, '..', '..', '..', 'resources', 'light', 'Git_Commit_16x.svg'),
            dark: path.join(__filename, '..', '..', '..', 'resources', 'dark', 'Git_Commit_16x.svg')
        };
    }
    get id() {
        this._deployResult.id = nonNull_1.nonNullProp(this._deployResult, 'id');
        return this._deployResult.id;
    }
    get description() {
        if (this._deployResult.active) {
            return localize_1.localize('active', 'Active');
        }
        switch (this._deployResult.status) {
            case DeployStatus.Building:
                return localize_1.localize('building', 'Building...');
            case DeployStatus.Deploying:
                return localize_1.localize('deploying', 'Deploying...');
            case DeployStatus.Pending:
                return localize_1.localize('pending', 'Pending...');
            case DeployStatus.Failed:
                return localize_1.localize('failed', 'Failed');
            case DeployStatus.Success:
            default:
                return;
        }
    }
    redeployDeployment() {
        return __awaiter(this, void 0, void 0, function* () {
            const redeploying = localize_1.localize('redeploying', 'Redeploying commit "{0}" to "{1}". Check output window for status.', this.id, this.root.client.fullName);
            const redeployed = localize_1.localize('redeployed', 'Commit "{0}" has been redeployed to "{1}".', this.id, this.root.client.fullName);
            yield vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Notification, title: redeploying }, () => __awaiter(this, void 0, void 0, function* () {
                const kuduClient = yield getKuduClient_1.getKuduClient(this.root.client);
                const refreshingInteveral = setInterval(() => __awaiter(this, void 0, void 0, function* () { yield this.refresh(); }), 1000); /* the status of the label changes during deployment so poll for that*/
                let getResultInterval;
                try {
                    yield new Promise((resolve, reject) => {
                        kuduClient.deployment.deploy(this.id).catch(reject);
                        getResultInterval = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                            const deployResult = yield kuduClient.deployment.getResult('latest');
                            if (deployResult && deployResult.id === this.id) {
                                resolve();
                            }
                        }), 3000);
                        const timeout = localize_1.localize('redeployTimeout', 'Redeploying commit "{0}" was unable to resolve and has timed out.', this.id);
                        // a 20 second timeout period to let Kudu initialize the deployment
                        setTimeout(() => reject(new Error(timeout)), 20000);
                    });
                    yield waitForDeploymentToComplete_1.waitForDeploymentToComplete(this.root.client, kuduClient);
                    yield this.parent.refresh(); /* refresh entire node because active statuses has changed */
                    vscode_1.window.showInformationMessage(redeployed);
                    extensionVariables_1.ext.outputChannel.appendLine(redeployed);
                }
                finally {
                    clearInterval(refreshingInteveral);
                    if (getResultInterval) {
                        clearInterval(getResultInterval);
                    }
                }
            }));
        });
    }
    getDeploymentLogs() {
        return __awaiter(this, void 0, void 0, function* () {
            const kuduClient = yield getKuduClient_1.getKuduClient(this.root.client);
            const logEntries = yield kuduClient.deployment.getLogEntry(this.id);
            let data = '';
            for (const logEntry of logEntries) {
                data += this.formatLogEntry(logEntry);
                if (logEntry.detailsUrl && logEntry.id) {
                    const detailedLogEntries = yield kuduClient.deployment.getLogEntryDetails(this.id, logEntry.id);
                    for (const detailedEntry of detailedLogEntries) {
                        data += this.formatLogEntry(detailedEntry);
                    }
                }
            }
            return data;
        });
    }
    viewDeploymentLogs() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.runWithTemporaryDescription(localize_1.localize('retrievingLogs', 'Retrieving logs...'), () => __awaiter(this, void 0, void 0, function* () {
                const logData = yield this.getDeploymentLogs();
                const logDocument = yield vscode_1.workspace.openTextDocument({ content: logData, language: 'log' });
                yield vscode_1.window.showTextDocument(logDocument);
            }));
        });
    }
    refreshLabelImpl() {
        return __awaiter(this, void 0, void 0, function* () {
            const kuduClient = yield getKuduClient_1.getKuduClient(this.root.client);
            // while this doesn't directly refresh the label, it's currently the only place to run async code on refresh
            this._deployResult = yield kuduClient.deployment.getResult(this.id);
        });
    }
    formatLogEntry(logEntry) {
        if (logEntry.logTime && logEntry.message) {
            return `${logEntry.logTime.toISOString()} - ${logEntry.message}${os.EOL}`;
        }
        else {
            return '';
        }
    }
    getFirstLine(message) {
        const allLineBreaks = /\r?\n|\r/;
        const index = message.search(allLineBreaks);
        if (index >= 0) {
            message = message.substring(0, index);
        }
        return message;
    }
}
DeploymentTreeItem.contextValue = 'deployment';
exports.DeploymentTreeItem = DeploymentTreeItem;
//# sourceMappingURL=DeploymentTreeItem.js.map