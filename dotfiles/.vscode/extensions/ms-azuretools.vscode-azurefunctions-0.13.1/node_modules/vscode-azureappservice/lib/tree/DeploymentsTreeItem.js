"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const vscode_azureextensionui_1 = require("vscode-azureextensionui");
const editScmType_1 = require("../editScmType");
const extensionVariables_1 = require("../extensionVariables");
const getKuduClient_1 = require("../getKuduClient");
const localize_1 = require("../localize");
const ScmType_1 = require("../ScmType");
const DeploymentTreeItem_1 = require("./DeploymentTreeItem");
class DeploymentsTreeItem extends vscode_azureextensionui_1.AzureParentTreeItem {
    constructor(parent, siteConfig, connectToGitHubCommandId) {
        super(parent);
        this.label = localize_1.localize('Deployments', 'Deployments');
        this.childTypeLabel = localize_1.localize('Deployment', 'Deployment');
        this.contextValue = siteConfig.scmType === ScmType_1.ScmType.None ? DeploymentsTreeItem.contextValueUnconnected : DeploymentsTreeItem.contextValueConnected;
        this._connectToGitHubCommandId = connectToGitHubCommandId;
    }
    get iconPath() {
        return {
            light: path.join(__filename, '..', '..', '..', 'resources', 'light', 'Deployments_x16.svg'),
            dark: path.join(__filename, '..', '..', '..', 'resources', 'dark', 'Deployments_x16.svg')
        };
    }
    hasMoreChildrenImpl() {
        return false;
    }
    loadMoreChildrenImpl(_clearCache) {
        return __awaiter(this, void 0, void 0, function* () {
            const siteConfig = yield this.root.client.getSiteConfig();
            if (siteConfig.scmType === ScmType_1.ScmType.GitHub || siteConfig.scmType === ScmType_1.ScmType.LocalGit) {
                const kuduClient = yield getKuduClient_1.getKuduClient(this.root.client);
                const deployments = yield kuduClient.deployment.getDeployResults();
                return yield vscode_azureextensionui_1.createTreeItemsWithErrorHandling(this, deployments, 'invalidDeployment', (dr) => {
                    return new DeploymentTreeItem_1.DeploymentTreeItem(this, dr);
                }, (dr) => {
                    return dr.id ? dr.id.substring(0, 7) : undefined;
                });
            }
            else {
                return [new vscode_azureextensionui_1.GenericTreeItem(this, {
                        commandId: this._connectToGitHubCommandId,
                        contextValue: 'ConnectToGithub',
                        label: 'Connect to a GitHub Repository...'
                    })];
            }
        });
    }
    compareChildrenImpl(ti1, ti2) {
        // sorts in accordance of the most recent deployment
        return ti2.receivedTime.valueOf() - ti1.receivedTime.valueOf();
    }
    disconnectRepo(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const sourceControl = yield this.root.client.getSourceControl();
            const disconnectButton = { title: localize_1.localize('disconnect', 'Disconnect') };
            const disconnect = localize_1.localize('disconnectFromRepo', 'Disconnect from "{0}"? This will not affect your app\'s active deployment. You may reconnect a repository at any time.', sourceControl.repoUrl);
            yield extensionVariables_1.ext.ui.showWarningMessage(disconnect, { modal: true }, disconnectButton, vscode_azureextensionui_1.DialogResponses.cancel);
            yield editScmType_1.editScmType(this.root.client, this.parent, context, ScmType_1.ScmType.None);
            yield this.refresh();
        });
    }
    refreshLabelImpl() {
        return __awaiter(this, void 0, void 0, function* () {
            const siteConfig = yield this.root.client.getSiteConfig();
            // while this doesn't directly refresh the label, it's currently the only place to run async code on refresh
            if (siteConfig.scmType === ScmType_1.ScmType.GitHub || siteConfig.scmType === ScmType_1.ScmType.LocalGit) {
                this.contextValue = DeploymentsTreeItem.contextValueConnected;
            }
            else {
                this.contextValue = DeploymentsTreeItem.contextValueUnconnected;
            }
        });
    }
}
DeploymentsTreeItem.contextValueConnected = 'deploymentsConnected';
DeploymentsTreeItem.contextValueUnconnected = 'deploymentsUnconnected';
exports.DeploymentsTreeItem = DeploymentsTreeItem;
//# sourceMappingURL=DeploymentsTreeItem.js.map