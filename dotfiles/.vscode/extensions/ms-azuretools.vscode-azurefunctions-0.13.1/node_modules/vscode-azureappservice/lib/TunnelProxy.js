"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const EventEmitter = require("events");
const net_1 = require("net");
const requestP = require("request-promise");
const vscode_azureextensionui_1 = require("vscode-azureextensionui");
const websocket = require("websocket");
const extensionVariables_1 = require("./extensionVariables");
/**
 * Wrapper for net.Socket that forwards all traffic to the Kudu tunnel websocket endpoint.
 * Used internally by the TunnelProxy server.
 */
class TunnelSocket extends EventEmitter {
    constructor(socket, client, publishCredential) {
        super();
        this._socket = socket;
        this._client = client;
        this._publishCredential = publishCredential;
        this._wsClient = new websocket.client();
    }
    connect() {
        extensionVariables_1.ext.outputChannel.appendLine('[Proxy Server] socket init');
        // Pause socket until tunnel connection has been established to make sure we don't lose data
        this._socket.pause();
        this._socket.on('data', (data) => {
            if (this._wsConnection) {
                this._wsConnection.send(data);
            }
        });
        this._socket.on('close', () => {
            extensionVariables_1.ext.outputChannel.appendLine(`[Proxy Server] client disconnected ${this._socket.remoteAddress}:${this._socket.remotePort}`);
            this.dispose();
            this.emit('close');
        });
        this._socket.on('error', (err) => {
            extensionVariables_1.ext.outputChannel.appendLine(`[Proxy Server] socket error: ${err}`);
            this.dispose();
            this.emit('error', err);
        });
        this._wsClient.on('connect', (connection) => {
            extensionVariables_1.ext.outputChannel.appendLine('[WebSocket] client connected');
            this._wsConnection = connection;
            // Resume socket after connection
            this._socket.resume();
            connection.on('close', () => {
                extensionVariables_1.ext.outputChannel.appendLine('[WebSocket] client closed');
                this.dispose();
                this.emit('close');
            });
            connection.on('error', (err) => {
                extensionVariables_1.ext.outputChannel.appendLine(`[WebSocket] error: ${err}`);
                this.dispose();
                this.emit('error', err);
            });
            connection.on('message', (data) => {
                this._socket.write(data.binaryData);
            });
        });
        this._wsClient.on('connectFailed', (err) => {
            extensionVariables_1.ext.outputChannel.appendLine(`[WebSocket] connectFailed: ${err}`);
            this.dispose();
            this.emit('error', err);
        });
        this._wsClient.connect(`wss://${this._client.kuduHostName}/AppServiceTunnel/Tunnel.ashx`, undefined, undefined, {
            'User-Agent': 'vscode-azuretools',
            'Cache-Control': 'no-cache',
            Pragma: 'no-cache'
        }, {
            auth: `${this._publishCredential.publishingUserName}:${this._publishCredential.publishingPassword}`
        });
    }
    dispose() {
        extensionVariables_1.ext.outputChannel.appendLine('[Proxy Server] socket dispose');
        if (this._wsConnection) {
            this._wsConnection.close();
            this._wsConnection = undefined;
        }
        this._wsClient.abort();
        this._socket.destroy();
    }
}
/**
 * Interface for tunnel GetStatus API
 */
var WebAppState;
(function (WebAppState) {
    WebAppState["STARTED"] = "STARTED";
    WebAppState["STARTING"] = "STARTING";
    WebAppState["STOPPED"] = "STOPPED";
})(WebAppState || (WebAppState = {}));
/**
 * Internal error indicating that we should continue to retry getting the tunnel status
 */
class RetryableTunnelStatusError extends Error {
}
/**
 * A local TCP server that forwards all connections to the Kudu tunnel websocket endpoint.
 */
class TunnelProxy {
    constructor(port, client, publishCredential) {
        this._port = port;
        this._client = client;
        this._publishCredential = publishCredential;
        this._server = net_1.createServer();
        this._openSockets = [];
    }
    startProxy() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkTunnelStatusWithRetry();
            yield this.setupTunnelServer();
        });
    }
    dispose() {
        this._openSockets.forEach((tunnelSocket) => {
            tunnelSocket.dispose();
        });
        this._server.close();
        this._server.unref();
    }
    checkTunnelStatus() {
        return __awaiter(this, void 0, void 0, function* () {
            const statusOptions = {
                uri: `https://${this._client.kuduHostName}/AppServiceTunnel/Tunnel.ashx?GetStatus&GetStatusAPIVer=2`,
                headers: {
                    'User-Agent': 'vscode-azuretools'
                },
                auth: {
                    user: this._publishCredential.publishingUserName,
                    pass: this._publishCredential.publishingPassword
                }
            };
            let tunnelStatus;
            try {
                // tslint:disable-next-line:no-unsafe-any
                const responseBody = yield requestP.get(statusOptions);
                extensionVariables_1.ext.outputChannel.appendLine(`[WebApp Tunnel] Checking status, body: ${responseBody}`);
                // tslint:disable-next-line:no-unsafe-any
                tunnelStatus = JSON.parse(responseBody);
            }
            catch (error) {
                const parsedError = vscode_azureextensionui_1.parseError(error);
                extensionVariables_1.ext.outputChannel.appendLine(`[WebApp Tunnel] Checking status, error: ${parsedError.message}`);
                throw new Error(`Error getting tunnel status: ${parsedError.errorType}`);
            }
            if (tunnelStatus.state === WebAppState.STARTED) {
                if (tunnelStatus.port === 2222) {
                    // Tunnel is pointed to default SSH port and still needs time to restart
                    throw new RetryableTunnelStatusError('WebApp is waiting for restart');
                }
                else if (tunnelStatus.canReachPort) {
                    return;
                }
                else {
                    throw new Error('WebApp is started, but port is unreachable');
                }
            }
            else if (tunnelStatus.state === WebAppState.STARTING) {
                throw new RetryableTunnelStatusError('WebApp is starting');
            }
            else if (tunnelStatus.state === WebAppState.STOPPED) {
                throw new Error('WebApp is stopped, try sending a request to start it up');
            }
            else {
                throw new Error(`Unexpected WebApp state: ${tunnelStatus.state}`);
            }
        });
    }
    checkTunnelStatusWithRetry() {
        return __awaiter(this, void 0, void 0, function* () {
            const timeoutSeconds = 240; // 4 minutes, matches App Service internal timeout for starting up an app
            const timeoutMs = timeoutSeconds * 1000;
            const pollingIntervalMs = 5000;
            const delay = (delayMs) => __awaiter(this, void 0, void 0, function* () {
                yield new Promise((resolve) => { setTimeout(resolve, delayMs); });
            });
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const start = Date.now();
                while (Date.now() < start + timeoutMs) {
                    try {
                        yield this.checkTunnelStatus();
                        resolve();
                        return;
                    }
                    catch (error) {
                        if (!(error instanceof RetryableTunnelStatusError)) {
                            reject(new Error(`Unable to establish connection to application: ${vscode_azureextensionui_1.parseError(error).message}`));
                            return;
                        } // else allow retry
                    }
                    yield delay(pollingIntervalMs);
                }
                reject(new Error('Unable to establish connection to application: Timed out'));
            }));
        });
    }
    setupTunnelServer() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this._server.on('connection', (socket) => {
                    const tunnelSocket = new TunnelSocket(socket, this._client, this._publishCredential);
                    this._openSockets.push(tunnelSocket);
                    tunnelSocket.on('close', () => {
                        const index = this._openSockets.indexOf(tunnelSocket);
                        if (index >= 0) {
                            this._openSockets.splice(index, 1);
                            extensionVariables_1.ext.outputChannel.appendLine(`[Proxy Server] client closed, connection count: ${this._openSockets.length}`);
                        }
                    });
                    tunnelSocket.connect();
                    extensionVariables_1.ext.outputChannel.appendLine(`[Proxy Server] client connected ${socket.remoteAddress}:${socket.remotePort}, connection count: ${this._openSockets.length}`);
                });
                this._server.on('listening', () => {
                    extensionVariables_1.ext.outputChannel.appendLine('[Proxy Server] start listening');
                    resolve();
                });
                this._server.on('error', (err) => {
                    extensionVariables_1.ext.outputChannel.appendLine(`[Proxy Server] server error: ${err}`);
                    this.dispose();
                    reject(err);
                });
                this._server.listen({
                    host: 'localhost',
                    port: this._port,
                    backlog: 1
                });
            });
        });
    }
}
exports.TunnelProxy = TunnelProxy;
//# sourceMappingURL=TunnelProxy.js.map